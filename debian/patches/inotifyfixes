Index: deejayd/deejayd/database/queries.py
===================================================================
--- deejayd.orig/deejayd/database/queries.py	2011-05-02 14:13:28.070142133 +0200
+++ deejayd/deejayd/database/queries.py	2011-05-02 14:14:06.154643120 +0200
@@ -189,11 +189,13 @@
         cursor.execute(query,(dir+u"%%", type))
 
     @query_decorator("fetchall")
-    def get_all_dirlinks(self, cursor, dirlink, type = 'audio'):
+    def get_all_dirlinks(self, cursor, dir, type = 'audio'):
+        if not dir[:-1] == '/': dir = dir+ u'/'
+
         query = "SELECT DISTINCT id,name FROM library_dir\
             WHERE name LIKE %s AND type='dirlink' AND lib_type = %s\
             ORDER BY name"
-        cursor.execute(query,(dirlink+u"%%", type))
+        cursor.execute(query,(dir+u"%%", type))
 
     def _medialist_answer(self, answer, infos = []):
         files = []
Index: deejayd/deejayd/mediadb/inotify.py
===================================================================
--- deejayd.orig/deejayd/mediadb/inotify.py	2011-05-02 14:13:28.082141800 +0200
+++ deejayd/deejayd/mediadb/inotify.py	2011-05-02 14:14:06.178641377 +0200
@@ -122,6 +122,11 @@
         name = library.fs_charset2unicode(event.name)
         # A decoding error would be raised and logged.
 
+        # Raised events use real paths, and in the libraries, paths follow
+        # symlinks on directories. Therefore, paths must be fixed to use
+        # symlinks before being passed on to the library.
+        path = library.library_path(path)
+
         if type == "create":
             if self.__occured_on_dirlink(library, event):
                 return library.add_directory(path, name, True)
@@ -187,16 +192,17 @@
     def watch_dir(self, dir_path, library):
         if self.is_watched(dir_path):
             raise ValueError('dir %s is already watched' % dir_path)
-        wdd = self.__wm.add_watch(dir_path, self.EVENT_MASK,
+        realpath = os.path.realpath(dir_path)
+        wdd = self.__wm.add_watch(realpath, self.EVENT_MASK,
                       proc_fun=InotifyWatcher(library,self.__queue), rec=True,
                       auto_add=True)
-        self.__watched_dirs[dir_path] = wdd
+        self.__watched_dirs[dir_path] = (realpath, wdd, )
 
     def stop_watching_dir(self, dir_path):
         if self.is_watched(dir_path):
-            wdd = self.__watched_dirs[dir_path]
+            (realpath, wdd, ) = self.__watched_dirs[dir_path]
             del self.__watched_dirs[dir_path]
-            self.__wm.rm_watch(wdd[dir_path], rec=True)
+            self.__wm.rm_watch(wdd[realpath], rec=True)
 
     def run(self):
         notifier = self.notifier(self.__wm)
Index: deejayd/deejayd/mediadb/library.py
===================================================================
--- deejayd.orig/deejayd/mediadb/library.py	2011-05-02 14:13:28.082141800 +0200
+++ deejayd/deejayd/mediadb/library.py	2011-05-02 14:14:06.182642758 +0200
@@ -170,6 +170,14 @@
             root_paths.append(dirlink)
         return root_paths
 
+    def library_path(self, realpath):
+        for root in self.get_root_paths():
+            if os.path.islink(root):
+                realroot = os.path.realpath(root)
+                if realpath.startswith(realroot):
+                    return os.path.join(root, realpath[len(realroot)+1:])
+        return realpath
+
     def get_status(self):
         status = []
         if not self._update_end:
